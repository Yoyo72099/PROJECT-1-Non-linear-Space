<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-Linear Text Art</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background-color: #1a1a1a; 
            background-image: url('https://github.com/Yoyo72099/PROJECT-1-Non-linear-Space/blob/main/æˆªå±2026-02-10%20ä¸‹åˆ5.06.52.png?raw=true');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }

        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .artwork-container {
            width: 85vw;
            height: 85vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #artworkCanvas {
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            cursor: pointer;
        }

        .scissors-cursor {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="%23ff0000" d="M8 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm8-6l12-6-1-2-12 6-2 1-2-1L-1 0l-1 2 12 6 2 1-2 1L-2 16l1 2 12-6 2-1 2 1 12 6 1-2-12-6-2-1z"/></svg>'), crosshair !important;
        }

        .cut-piece {
            position: absolute;
            cursor: move;
            user-select: none;
            z-index: 10;
            filter: drop-shadow(0 8px 20px rgba(0, 0, 0, 0.5));
        }

        .cut-piece:hover {
            z-index: 20;
            filter: drop-shadow(0 12px 30px rgba(255, 255, 255, 0.4));
        }

        .cut-piece.dragging {
            opacity: 0.9;
            z-index: 100;
            transform: rotate(2deg);
            filter: drop-shadow(0 20px 40px rgba(0, 0, 0, 0.7));
        }

        .instruction {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 20px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            animation: fadeInOut 5s ease-in-out;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            15%, 85% { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        .reset-button {
            position: absolute;
            top: 30px;
            right: 30px;
            background: linear-gradient(135deg, rgba(120, 120, 120, 0.9), rgba(80, 80, 80, 0.9));
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
            display: none;
        }

        .reset-button.active {
            display: block;
        }

        .reset-button:hover {
            background: linear-gradient(135deg, rgba(140, 140, 140, 1), rgba(100, 100, 100, 1));
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
        }

        .cut-line {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="artwork-container" id="artworkContainer">
            <canvas id="artworkCanvas"></canvas>
        </div>
        <button class="reset-button" id="resetButton">Reset Artwork</button>
    </div>

    <script>
        let scissorsMode = false;
        let cutPieces = [];
        let isCutting = false;
        let cutPath = [];
        let draggedElement = null;
        let offsetX = 0;
        let offsetY = 0;
        let originalImage = null;

        const canvas = document.getElementById('artworkCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('artworkContainer');
        const resetButton = document.getElementById('resetButton');

        // ==========================================
        // åœ¨è¿™é‡Œè®¾ç½®ä½ çš„å›¾ç‰‡å’ŒéŸ³æ•ˆ
        // ==========================================
        const ARTWORK_URL = 'https://github.com/Yoyo72099/PROJECT-1-Non-linear-Space/blob/main/æˆªå±2026-02-10%20ä¸‹åˆ5.09.31.png?raw=true';
        const SCISSOR_SOUND_URL = 'YOUR_SCISSOR_SOUND_URL_HERE.mp3';
        
        let scissorAudio = null;
        try {
            scissorAudio = new Audio(SCISSOR_SOUND_URL);
            scissorAudio.volume = 0.5;
        } catch(e) {
            console.log('Audio not loaded');
        }

        function playScissorSound() {
            if (scissorAudio) {
                scissorAudio.currentTime = 0;
                scissorAudio.play().catch(() => {});
            }
        }

        // åŠ è½½å›¾ç‰‡
        function loadArtwork() {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = function() {
                originalImage = img;
                
                // è®¾ç½®canvaså¤§å°ä»¥é€‚åº”å›¾ç‰‡
                const maxWidth = window.innerWidth * 0.85;
                const maxHeight = window.innerHeight * 0.85;
                const scale = Math.min(maxWidth / img.width, maxHeight / img.height, 1);
                
                canvas.width = img.width * scale;
                canvas.height = img.height * scale;
                
                // ç»˜åˆ¶å›¾ç‰‡
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                
                showInstruction('ğŸ¨ Double-click to activate scissors!');
            };
            img.onerror = function() {
                showInstruction('âš ï¸ Failed to load image. Check your URL!');
            };
            img.src = ARTWORK_URL;
        }

        // æ˜¾ç¤ºæç¤º
        function showInstruction(text) {
            const instruction = document.createElement('div');
            instruction.className = 'instruction';
            instruction.textContent = text;
            document.body.appendChild(instruction);
            setTimeout(() => instruction.remove(), 5000);
        }

        // åŒå‡»æ¿€æ´»å‰ªåˆ€
        canvas.addEventListener('dblclick', function(e) {
            if (!scissorsMode && originalImage) {
                scissorsMode = true;
                container.classList.add('scissors-cursor');
                resetButton.classList.add('active');
                showInstruction('âœ‚ï¸ Drag to cut! Release to finish cutting');
            }
            e.preventDefault();
        });

        // å¼€å§‹å‰ªåˆ‡
        canvas.addEventListener('mousedown', function(e) {
            if (!scissorsMode || !originalImage) return;
            
            isCutting = true;
            cutPath = [];
            const rect = canvas.getBoundingClientRect();
            cutPath.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
            
            playScissorSound();
            e.preventDefault();
        });

        // å‰ªåˆ‡ä¸­ - è®°å½•è·¯å¾„
        canvas.addEventListener('mousemove', function(e) {
            if (!isCutting) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            cutPath.push({ x, y });
            
            // ç»˜åˆ¶å‰ªåˆ‡çº¿
            if (cutPath.length > 1) {
                const prev = cutPath[cutPath.length - 2];
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(prev.x, prev.y);
                ctx.lineTo(x, y);
                ctx.stroke();
            }
        });

        // ç»“æŸå‰ªåˆ‡ - åˆ†å‰²å›¾ç‰‡
        canvas.addEventListener('mouseup', function(e) {
            if (!isCutting) return;
            
            isCutting = false;
            
            if (cutPath.length > 10) {
                performCut();
            }
            
            cutPath = [];
        });

        // æ‰§è¡Œå‰ªåˆ‡ - æŠŠå›¾ç‰‡æ²¿ç€è·¯å¾„åˆ†æˆä¸¤éƒ¨åˆ†
        function performCut() {
            const rect = canvas.getBoundingClientRect();
            
            // åˆ›å»ºä¸¤ä¸ªæ–°çš„canvasç‰‡æ®µ
            const canvasData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // ç®€åŒ–ç‰ˆï¼šåˆ›å»ºæ²¿ç€å‰ªåˆ‡çº¿çš„ä¸¤ä¾§ç‰‡æ®µ
            // ä¸ŠåŠéƒ¨åˆ†
            const piece1 = createPieceFromPath(canvasData, cutPath, true);
            if (piece1) {
                const img1 = document.createElement('img');
                img1.src = piece1.canvas.toDataURL();
                img1.className = 'cut-piece';
                img1.style.width = piece1.width + 'px';
                img1.style.height = piece1.height + 'px';
                img1.style.left = (rect.left + piece1.x) + 'px';
                img1.style.top = (rect.top + piece1.y) + 'px';
                document.body.appendChild(img1);
                cutPieces.push(img1);
                makeDraggable(img1);
            }
            
            // ä¸‹åŠéƒ¨åˆ†
            const piece2 = createPieceFromPath(canvasData, cutPath, false);
            if (piece2) {
                const img2 = document.createElement('img');
                img2.src = piece2.canvas.toDataURL();
                img2.className = 'cut-piece';
                img2.style.width = piece2.width + 'px';
                img2.style.height = piece2.height + 'px';
                img2.style.left = (rect.left + piece2.x) + 'px';
                img2.style.top = (rect.top + piece2.y) + 'px';
                document.body.appendChild(img2);
                cutPieces.push(img2);
                makeDraggable(img2);
            }
            
            // æ¸…ç©ºåŸcanvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.style.display = 'none';
            
            showInstruction('âœ‚ï¸ Cut complete! Drag pieces to rearrange');
        }

        // åˆ›å»ºå‰ªåˆ‡ç‰‡æ®µ
        function createPieceFromPath(imageData, path, isTop) {
            if (path.length < 2) return null;
            
            // æ‰¾åˆ°è¾¹ç•Œ
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            path.forEach(p => {
                minX = Math.min(minX, p.x);
                minY = Math.min(minY, p.y);
                maxX = Math.max(maxX, p.x);
                maxY = Math.max(maxY, p.y);
            });
            
            // æ‰©å±•è¾¹ç•Œ
            if (isTop) {
                minY = 0;
            } else {
                maxY = canvas.height;
            }
            minX = Math.max(0, Math.floor(minX - 10));
            maxX = Math.min(canvas.width, Math.ceil(maxX + 10));
            minY = Math.max(0, Math.floor(minY - 10));
            maxY = Math.min(canvas.height, Math.ceil(maxY + 10));
            
            const width = maxX - minX;
            const height = maxY - minY;
            
            if (width <= 0 || height <= 0) return null;
            
            // åˆ›å»ºæ–°canvas
            const pieceCanvas = document.createElement('canvas');
            pieceCanvas.width = width;
            pieceCanvas.height = height;
            const pieceCtx = pieceCanvas.getContext('2d');
            
            // å¤åˆ¶å›¾åƒæ•°æ®
            const pieceData = pieceCtx.createImageData(width, height);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const srcX = minX + x;
                    const srcY = minY + y;
                    const srcIndex = (srcY * canvas.width + srcX) * 4;
                    const dstIndex = (y * width + x) * 4;
                    
                    pieceData.data[dstIndex] = imageData.data[srcIndex];
                    pieceData.data[dstIndex + 1] = imageData.data[srcIndex + 1];
                    pieceData.data[dstIndex + 2] = imageData.data[srcIndex + 2];
                    pieceData.data[dstIndex + 3] = imageData.data[srcIndex + 3];
                }
            }
            
            pieceCtx.putImageData(pieceData, 0, 0);
            
            return {
                canvas: pieceCanvas,
                x: minX,
                y: minY,
                width: width,
                height: height
            };
        }

        // ä½¿ç‰‡æ®µå¯æ‹–åŠ¨
        function makeDraggable(element) {
            element.addEventListener('mousedown', startDrag);
            
            function startDrag(e) {
                if (scissorsMode) return; // å‰ªåˆ‡æ¨¡å¼ä¸‹ä¸æ‹–åŠ¨
                
                draggedElement = element;
                element.classList.add('dragging');
                
                const rect = element.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                
                e.preventDefault();
                e.stopPropagation();
            }
            
            function drag(e) {
                if (!draggedElement) return;
                
                draggedElement.style.left = (e.clientX - offsetX) + 'px';
                draggedElement.style.top = (e.clientY - offsetY) + 'px';
            }
            
            function stopDrag() {
                if (draggedElement) {
                    draggedElement.classList.remove('dragging');
                    draggedElement = null;
                }
                document.removeEventListener('mousemove', drag);
                document.removeEventListener('mouseup', stopDrag);
            }
        }

        // é‡ç½®
        resetButton.addEventListener('click', function() {
            cutPieces.forEach(piece => piece.remove());
            cutPieces = [];
            
            scissorsMode = false;
            container.classList.remove('scissors-cursor');
            resetButton.classList.remove('active');
            
            canvas.style.display = 'block';
            if (originalImage) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            }
            
            showInstruction('ğŸ”„ Reset! Double-click to start again');
        });

        // åŠ è½½å›¾ç‰‡
        loadArtwork();
    </script>
</body>
</html>
